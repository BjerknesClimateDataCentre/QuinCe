package uk.ac.exeter.QuinCe.data.Dataset.DataReduction;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.math3.stat.regression.SimpleRegression;

import uk.ac.exeter.QuinCe.data.Dataset.DateColumnGroupedSensorValues;
import uk.ac.exeter.QuinCe.data.Dataset.Measurement;
import uk.ac.exeter.QuinCe.data.Dataset.SensorValue;
import uk.ac.exeter.QuinCe.data.Dataset.QC.Flag;
import uk.ac.exeter.QuinCe.data.Instrument.Instrument;
import uk.ac.exeter.QuinCe.data.Instrument.Calibration.CalibrationSet;
import uk.ac.exeter.QuinCe.data.Instrument.SensorDefinition.SensorAssignments;
import uk.ac.exeter.QuinCe.data.Instrument.SensorDefinition.SensorConfigurationException;
import uk.ac.exeter.QuinCe.data.Instrument.SensorDefinition.SensorType;
import uk.ac.exeter.QuinCe.data.Instrument.SensorDefinition.SensorTypeNotFoundException;
import uk.ac.exeter.QuinCe.data.Instrument.SensorDefinition.SensorsConfiguration;
import uk.ac.exeter.QuinCe.utils.DateTimeUtils;
import uk.ac.exeter.QuinCe.utils.RecordNotFoundException;
import uk.ac.exeter.QuinCe.web.system.ResourceManager;

/**
 * A DataReducer will perform all data reduction calculations
 * for a given variable. The output from the data reduction is
 * an instance of the DataReductionRecord class
 * 
 * @author Steve Jones
 *
 */
public abstract class DataReducer {

  /**
   * All the measurements from the current data set
   */
  protected List<Measurement> allMeasurements;

  /**
   * A local copy of the complete set of sensor values for the current data set
   */
  protected DateColumnGroupedSensorValues groupedSensorValues;
  
  /**
   * The internal calibrations for the current data set
   */
  protected CalibrationSet calibrationSet;
  
  /**
   * The calculation parameters generated by this data reducer
   */
  protected LinkedHashMap<String, Double> calculationParameters;
  
  public DataReducer(List<Measurement> allMeasurements,
      DateColumnGroupedSensorValues groupedSensorValues,
      CalibrationSet calibrationSet) {
    
    this.allMeasurements = allMeasurements;
    this.groupedSensorValues = groupedSensorValues;
    this.calibrationSet = calibrationSet;

    // Initialise the calculation parameters
    calculationParameters = new LinkedHashMap<String, Double>();
    for (String parameter : getCalculationParameterNames()) {
      calculationParameters.put(parameter, null);
    }
  }
  
  /**
   * Perform the data reduction and set up the QC flags
   * @param instrument The instrument that took the measurement
   * @param measurement The measurement
   * @param sensorValues The measurement's sensor values
   * @param allMeasurements All measurements for the data set
   * @return The data reduction result
   */
  public DataReductionRecord performDataReduction(Instrument instrument,
      Measurement measurement, Map<SensorType, CalculationValue> sensorValues) throws Exception {
    
    DataReductionRecord record = new DataReductionRecord(measurement);
    doCalculation(instrument, measurement, sensorValues, record);
    
    return record;
  }
  
  /**
   * Perform the data reduction calculations
   * @param instrument The instrument that took the measurement
   * @param measurement The measurement
   * @param sensorValues The measurement's sensor values
   * @param allMeasurements All measurements for the data set
   * @param record The data reduction result
   */
  protected abstract void doCalculation(Instrument instrument,
      Measurement measurement, Map<SensorType, CalculationValue> sensorValues,
      DataReductionRecord record)
      throws Exception;
  
  /**
   * Set a data reduction record's state for a missing required parameter
   * @param record The record
   * @param missingParameterName The name of the missing parameter
   */
  protected void makeMissingParameterRecord(
      DataReductionRecord record, Set<SensorType> missingTypes) {
    
    List<String> qcMessages = new ArrayList<String>(missingTypes.size());
    
    for (String parameter : getCalculationParameterNames()) {
      record.put(parameter, Double.NaN);
    }
    
    for (SensorType type : missingTypes) {
      qcMessages.add("Missing " + type.getName());
    }
    
    record.setQc(Flag.NO_QC, qcMessages);
  }
  
  /**
   * Get the calculation parameters generated by the reducer, in
   * display order
   * @return The calculation parameters
   */
  protected abstract List<String> getCalculationParameterNames();
  
  /**
   * Get the list of SensorTypes required by this data reducer. This takes
   * the minimum list of sensor types (or parent types) and determines the
   * actual required types according to the sensor types assigned to the
   * instrument and their dependents.
   * 
   * @param instrumentAssignments The sensor types assigned to the instrument
   * @param sensorTypeNames The names of the bare minimum sensor types
   * @return The complete list of required SensorType objects
   */
  protected Set<SensorType> getRequiredSensorTypes(
    SensorAssignments instrumentAssignments, String... sensorTypeNames)
    throws DataReductionException {
    
    Set<SensorType> result = new HashSet<SensorType>(sensorTypeNames.length);
    
    try {
      SensorsConfiguration sensorConfig =
          ResourceManager.getInstance().getSensorsConfiguration();
        
        for (String sensorTypeName : sensorTypeNames) {
          SensorType baseSensorType = sensorConfig.getSensorType(sensorTypeName);
          
          if (sensorConfig.isParent(baseSensorType)) {
            Set<SensorType> childSensorTypes = sensorConfig.getChildren(baseSensorType);
            if (!addAnySensorTypesAndDependsOn(result, childSensorTypes, instrumentAssignments)) {
              throw new DataReductionException(
                "No assignments present for children of Sensor Type "
                + baseSensorType.getName() + " or their dependents");
            }
          } else {
            if (!addSensorTypeAndDependsOn(result, baseSensorType, instrumentAssignments)) {
              throw new DataReductionException(
                "No assignments present for Sensor Type "
                + baseSensorType.getName() + " or its dependents");
            }
          }
        }
    } catch (SensorTypeNotFoundException e) {
      throw new DataReductionException("Named sensor type not found", e);
    } catch (SensorConfigurationException e) {
      throw new DataReductionException("Invalid sensor configuration detected", e); 
    }
    
    return result;
  }
  
  /**
   * Add a set of Sensor Types to an existing list of Sensor Types, including
   * any dependents
   * 
   * @param list The list to which the sensor types are to be added
   * @param typesToAdd The sensor types to add
   * @param instrumentAssignments The instrument's sensor assignments
   * @return {@code true}Â if at least one Sensor Type is added; {@code false} if
   *         none are added (unless the list is empty)
   * @throws SensorConfigurationException 
   * @throws SensorTypeNotFoundException 
   */
  private boolean addAnySensorTypesAndDependsOn(Set<SensorType> list,
    Set<SensorType> typesToAdd, SensorAssignments instrumentAssignments)
    throws SensorConfigurationException, SensorTypeNotFoundException {
    
    boolean result = false;
    
    if (typesToAdd.size() == 0) {
      result = true;
    } else {
      for (SensorType add : typesToAdd) {
        if (addSensorTypeAndDependsOn(list, add, instrumentAssignments)) {
          result = true;
        }
      }
    }
    
    return result;
  }
  
  /**
   * Add a Sensor Type to an existing list of Sensor Types, including
   * any dependents
   * 
   * @param list The list to which the sensor types are to be added
   * @param typesToAdd The sensor types to add
   * @param instrumentAssignments The instrument's sensor assignments
   * @throws SensorConfigurationException 
   * @throws SensorTypeNotFoundException 
   */
  private boolean addSensorTypeAndDependsOn(Set<SensorType> list,
    SensorType typeToAdd, SensorAssignments instrumentAssignments)
    throws SensorConfigurationException, SensorTypeNotFoundException {
    
    boolean result = true;
    
    if (!instrumentAssignments.isAssigned(typeToAdd)) {
      result = false;
    } else {
      list.add(typeToAdd);
      SensorType dependsOn = instrumentAssignments.getDependsOn(typeToAdd);
      if (null != dependsOn) {
        if (!addSensorTypeAndDependsOn(list, dependsOn, instrumentAssignments)) {
          result = false;
        }
      }
    }

    return result;
  }
  
  /**
   * See if any required values are NaN in the supplied set of values. If there
   * are NaNs, make the record a blank and return {@code true}.
   * @param record The record being processed
   * @param values The calculation values
   * @param requiredTypes The required sensor types
   * @return
   */
  protected boolean nanCheck(DataReductionRecord record,
    Map<SensorType, CalculationValue> values, Set<SensorType> requiredTypes) {
    
    Set<SensorType> nanTypes = new HashSet<SensorType>();
    
    for (SensorType type : requiredTypes) {
      CalculationValue value = values.get(type);
      if (null == value || value.isNaN()) {
        nanTypes.add(type);
      }
    }
    
    if (nanTypes.size() > 0) {
      makeMissingParameterRecord(record, nanTypes);
    }
    
    return (nanTypes.size() > 0);
  }
  

  /**
   * Apply external standards calibration to a sensor value
   *
   * @param recordDate The date of the record from which the sensor value was taken
   * @param sensorName The name of the sensor
   * @param calculationValue The sensor value to be calibrated
   * @param ignoreZero Indicates whether or not the zero standard should be ignored
   * @return The calibrated sensor value
   * @throws DataReductionException If there are not sufficient standard measurements
   */
  protected Double applyValueCalibration(Measurement measurement, SensorType sensorType, CalculationValue originalValue, boolean ignoreZero) throws DataReductionException {
    return applyValueCalibration(measurement, sensorType, originalValue.getValue(), ignoreZero);
  }

  /**
   * Apply external standards calibration to a sensor value
   *
   * @param recordDate The date of the record from which the sensor value was taken
   * @param sensorName The name of the sensor
   * @param calculationValue The sensor value to be calibrated
   * @param ignoreZero Indicates whether or not the zero standard should be ignored
   * @return The calibrated sensor value
   * @throws DataReductionException If there are not sufficient standard measurements
   */
  protected Double applyValueCalibration(Measurement measurement, SensorType sensorType, Double originalValue, boolean ignoreZero) throws DataReductionException {

    // TODO Add excessive calibration adjustment check to this method -
    // it will set the flag on the CalculationValue
    
    Double calibratedValue;

    // Get the before and after measurements for each run type
    try {

      // For each external standard target, calculate the offset from the external
      // standard at the record date
      Map<String, Double> standardMeasurements = new HashMap<String, Double>();
      for (String target : calibrationSet.getTargets().keySet()) {
        double concentration = calibrationSet.getCalibrationValue(target, sensorType.getName());
        if (!ignoreZero || concentration > 0.0) {
          
          CalculationValue priorCalibrationValue = null;
          LocalDateTime priorCalibrationTime = getPreviousTime(measurement, target, sensorType);
          if (null != priorCalibrationTime) {
            priorCalibrationValue = CalculationValue.get(sensorType,
              groupedSensorValues.get(priorCalibrationTime).get(sensorType));
          }
          
          CalculationValue postCalibrationValue = null;
          LocalDateTime postCalibrationTime = getNextTime(measurement, target, sensorType);
          if (null != postCalibrationTime) {
            postCalibrationValue = CalculationValue.get(sensorType,
              groupedSensorValues.get(postCalibrationTime).get(sensorType));
          }

          standardMeasurements.put(target, calculateStandardValueAtDate(measurement.getTime(), target, priorCalibrationTime, priorCalibrationValue, postCalibrationTime, postCalibrationValue));
        }
      }

      // Make a regression of the offsets to calculate the offset at the measured concentration
      SimpleRegression regression = new SimpleRegression(true);
      for (String target : standardMeasurements.keySet()) {
        regression.addData(standardMeasurements.get(target), calibrationSet.getCalibrationValue(target, sensorType.getName()));
      }

      calibratedValue = regression.predict(originalValue);

    } catch (Exception e) {
      if (e instanceof DataReductionException) {
        throw (DataReductionException) e;
      } else {
        throw new DataReductionException("Error while applying internal calibration", e);
      }
    }

    return calibratedValue;
  }

  /**
   * Calculate the measured external standard value at a given date between
   * two calibration measurements.
   *
   * One of the calibrations can be {@code null}, in which case the
   * value that of the calibration measurement that is
   * not {@null}. If both measurements are {@code null} an error is thrown.
   *
   * @param date The target date for which the value is to be calculated
   * @param target The name of the external standard
   * @param sensorName The name of the sensor whose offset is being calculated
   * @param priorCalibration The calibration measurement prior to the {@code date}
   * @param postCalibration The calibration measurement after the {@code date}
   * @return The value at the specified date
   * @throws RecordNotFoundException If both calibration measurements are {@code null}.
   */
  private Double calculateStandardValueAtDate(LocalDateTime date, String target, LocalDateTime priorCalibrationTime, CalculationValue priorCalibration, LocalDateTime postCalibrationTime, CalculationValue postCalibration) throws RecordNotFoundException {

    Double result;

    if (null == priorCalibration && null == postCalibration) {
      throw new RecordNotFoundException("No calibrations found for external standard '" + target + "'");
    } else if (null == priorCalibration) {
      result = postCalibration.getValue();
    } else if (null == postCalibration) {
      result = priorCalibration.getValue();
    } else {
        double priorMeasuredValue = priorCalibration.getValue();
        double postMeasuredValue = postCalibration.getValue();
        SimpleRegression regression = new SimpleRegression(true);
        regression.addData(DateTimeUtils.dateToLong(priorCalibrationTime), priorMeasuredValue);
        regression.addData(DateTimeUtils.dateToLong(postCalibrationTime), postMeasuredValue);
        result = regression.predict(DateTimeUtils.dateToLong(date));
    }

    return result;
  }
  
  /**
   * Get the last measurement prior to the specified date with the
   * specified run type. Returns {@code null} if there is no matching record
   * @param time The time
   * @param runType The run type
   * @return The previous measurement
   */
  private LocalDateTime getPreviousTime(Measurement start, String runType, SensorType sensorType) {
    
    // TODO This and getNextTime can be refactored together
    
    LocalDateTime result = null;
    
    int i = allMeasurements.indexOf(start) - 1;
    while (null == result && i >= 0) {
      Measurement currentMeasurement = allMeasurements.get(i);
      if (currentMeasurement.getRunType().equals(runType)) {
        Map<SensorType, List<SensorValue>> measurementData =
          groupedSensorValues.get(currentMeasurement.getTime());
        
        CalculationValue value = CalculationValue.get(sensorType, measurementData.get(sensorType));
        if (!value.isNaN()) {
          result = currentMeasurement.getTime();
        }
      }

      i--;
    }
    
    return result;
  }
  
  /**
   * Get the first measurement after the specified date with the
   * specified run type. Returns {@code null} if there is no matching record
   * @param time The time
   * @param runType The run type
   * @return The previous measurement
   */
  private LocalDateTime getNextTime(Measurement start, String runType, SensorType sensorType) {
    LocalDateTime result = null;
    
    int i = allMeasurements.indexOf(start) + 1;
    while (null == result && i < allMeasurements.size()) {
      Measurement currentMeasurement = allMeasurements.get(i);
      if (currentMeasurement.getRunType().equals(runType)) {
        Map<SensorType, List<SensorValue>> measurementData =
          groupedSensorValues.get(currentMeasurement.getTime());
        
        CalculationValue value = CalculationValue.get(sensorType, measurementData.get(sensorType));
        if (!value.isNaN()) {
          result = currentMeasurement.getTime();
        }
      }
      
      i++;
    }
    
    return result;
  }
  
  protected SensorType getSensorType(Set<SensorType> sensorTypes, String sensorTypeName) {
    SensorType result = null;
    
    for (SensorType sensorType : sensorTypes) {
      if (sensorType.getName().equals(sensorTypeName)) {
        result = sensorType;
        break;
      }
    }
    
    return result;
  }
  
  protected Double getValue(Set<SensorType> sensorTypes, Map<SensorType, CalculationValue> sensorValues, String sensorTypeName) {
    SensorType sensorType = getSensorType(sensorTypes, sensorTypeName);
    return sensorValues.get(sensorType).getValue();
  }
}
